<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[图片猫脸转换加密]]></title>
    <url>%2F2024%2F11%2F03%2F%E5%9B%BE%E7%89%87%E7%8C%AB%E8%84%B8%E8%BD%AC%E6%8D%A2%E5%8A%A0%E5%AF%86%2F</url>
    <content type="text"><![CDATA[Arnold变换上文提到异或加密比较简单，会被已知明文攻击。所以本次引入一个猫脸转换加密，参考An overview of encryption algorithms in color images。 猫脸变换即Arnold变换，据说是因第一张验证图片是猫脸而得名。可以对图像进行置乱，使得原本有意义的图像变成一张无意义的图像。可以看作是拉伸，压缩，折叠及拼接的过程（仿射变换），使得原本有意义的图像变成一张无意义的图像。通过这一过程，可以将离散化的数字图像矩阵中的点重新排列，使其他人无法获取图像真实内容。该变换可以用于图片加密，也可以用于水印部分的置乱。 当图像的长宽相等是，Arnold可以进行逆变换。相应的变换公式和逆变换公式可以用于快速的加密和解密。 正变换公式如下： $\left(\begin{array}{cc}x’ \ y’ \end{array}\right)=\left[\begin{array}{a}1 &amp; a \ b &amp; ab+1 \end{array} \right]\left(\begin{array}{b} x \y \end{array} \right)mod(N)$ 逆变换公式如下： $\left(\begin{array}{cc}x \ y \end{array}\right)=\left[\begin{array}{a}ab+1 &amp; -a \ -b &amp; 1 \end{array} \right]\left(\begin{array}{b} x’ \y’ \end{array} \right)mod(N)$ 通常一次Arnold变换达不到理想效果，需要对图像进行连续多次的变换。Arnold变换具有周期性，即对图像连续进行Arnold变换，最终又能得到原图像。变换的周期和图像的尺寸有关，统计如下表： 表1-1 Arnold变换周期 边长N 2 4 8 16 32 64 128 246 512 1024 周期T 3 3 6 12 24 48 96 192 384 768 变换代码123456789101112def arnold(img, shuffle_times, a, b): """Arnold's cat map""" r, c, d = img.shape p = np.zeros(img.shape, np.uint8) for s in range(shuffle_times): for i in range(r): for j in range(c): x = (i + b * j) % r y = (a * i + (a * b + 1) * j) % c p[x, y, :] = img[i, j, :] img = np.copy(p) return p 逆变换代码123456789101112def de_arnold(img, shuffle_times, a, b): """Arnold's cat map""" r, c, d = img.shape p = np.zeros(img.shape, np.uint8) for s in range(shuffle_times): for i in range(r): for j in range(c): x = ((a * b + 1) * i - b * j) % r y = (- a * i + j) % c p[x, y, :] = img[i, j, :] img = np.copy(p) return p 验证不同参数12345678910111213141516171819202122232425262728293031323334353637def test_arnold(): """测试Arnold's cat map""" img = cv2.imread(data_file_path('data/image/lena.png')) plt.subplot(231) plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB)) plt.axis('off') plt.title("Lena") plt.subplot(232) plt.imshow(cv2.cvtColor(arnold(img, 1, 1, 1), cv2.COLOR_BGR2RGB)) plt.axis('off') plt.title("Lena encrypt t1-a1-b1") plt.subplot(233) plt.imshow(cv2.cvtColor(arnold(img, 2, 1, 1), cv2.COLOR_BGR2RGB)) plt.axis('off') plt.title("encrypt t2-a1-b1") plt.subplot(234) plt.imshow(cv2.cvtColor(arnold(img, 3, 1, 1), cv2.COLOR_BGR2RGB)) plt.axis('off') plt.title("encrypt t3-a1-b1") encrypt_img = arnold(img, 5, 1, 2) plt.subplot(235) plt.imshow(cv2.cvtColor(arnold(img, 5, 1, 2), cv2.COLOR_BGR2RGB)) plt.axis('off') plt.title("encrypt t5-a1-b2") decrypt_img = de_arnold(encrypt_img, 5, 1, 2) plt.subplot(236) plt.imshow(cv2.cvtColor(decrypt_img, cv2.COLOR_BGR2RGB)) plt.axis('off') plt.title("decrypt t5-a1-b2") plt.show() 代码输出如下： 可以看到虽然5次a=1 b=2的变换后图片已经摇匀了，但是经过一次逆变换还是可以无损变回原图。 验证直方图不变Arnold变换只是改变了像素值的位置，其像素值是没发生变化的，因此其像素直方图统计特性是没有改变的，非常有利于采用直方图平移嵌入额外信息。也正是因为像素值没发生变化，其图像的信息内容存在着泄漏可能。 123456789101112131415161718192021222324252627282930313233343536373839def test_histogram(): """猫脸变化直方图""" img = cv2.imread(data_file_path('data/image/lena.png')) gray_img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) hist = cv2.calcHist([gray_img], [0], None, [256], [0, 255]) # 计算图像第一个通道的直方图 encrypt_img = arnold(img, 1, 1, 1) gray_encrypt_img = cv2.cvtColor(encrypt_img, cv2.COLOR_BGR2GRAY) encrypt_hist = cv2.calcHist([gray_encrypt_img], [0], None, [256], [0, 255]) # 计算图像第一个通道的直方图 assert np.array_equal(hist, encrypt_hist) # 设置字体 matplotlib.rcParams['font.sans-serif'] = ['SimHei'] # 显示原始图像和绘制的直方图 plt.subplot(221) plt.imshow(gray_img, 'gray') plt.axis('off') plt.title("(a)Lena灰度图像") plt.subplot(222) plt.plot(hist, color='r') plt.xlabel("x") plt.ylabel("y") plt.title("(b)直方图曲线") plt.subplot(223) plt.imshow(gray_encrypt_img, 'gray') plt.axis('off') plt.title("(a)Lena转换后灰度图像") plt.subplot(224) plt.plot(encrypt_hist, color='r') plt.xlabel("x") plt.ylabel("y") plt.title("(b)直方图曲线") plt.show() 输出结果参考 验证周期如果图片的长不等于宽时，Arnold变换逆变换不成立，如何还原图像呢。这时候就可以结合周期表了，我们让图片变换周期次数就可以了。那么问题又来了，长宽不等，那么对应的周期也不等，我们选择长的周期还是宽的周期。一个保守的方案是选择长周期和宽周期的最小公倍数。 通过狭义的（a=1,b-1）Arnold变换周期表，我们大概可以看到周期约等于边长的0.75倍。为了方便演示，我们吧lena图片进行缩放为（32,64），结合周期表知道64的周期为48.进行验证如下： 123456789101112131415161718192021222324252627282930 def test_arnold_period(): """猫脸变化直方图""" img = cv2.imread(data_file_path('data/image/lena.png')) img_small = cv2.resize(img, (32, 64), interpolation=cv2.INTER_AREA) plt.subplot(221) plt.imshow(cv2.cvtColor(img_small, cv2.COLOR_BGR2RGB)) plt.axis('off') plt.title("(b)Lena 32*64") encrypt = arnold(img_small, 1, 1, 1) plt.subplot(222) plt.imshow(cv2.cvtColor(encrypt, cv2.COLOR_BGR2RGB)) plt.axis('off') plt.title("encrypt t1-a1-b1") plt.subplot(223) # 逆变换已经不管用了 plt.imshow(cv2.cvtColor(de_arnold(encrypt, 1, 1, 1), cv2.COLOR_BGR2RGB)) plt.axis('off') plt.title("decrypt t1-a1-b1") plt.subplot(224) # 47 对应边长64的周期48（应该是长宽两个周期的最小公倍数）然后减去1，即47 plt.imshow(cv2.cvtColor(arnold(encrypt, 47, 1, 1), cv2.COLOR_BGR2RGB)) plt.axis('off') plt.title("decrypt t48-a1-b1") plt.show()]]></content>
      <categories>
        <category>CV</category>
      </categories>
      <tags>
        <tag>CV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图片异或加密]]></title>
    <url>%2F2024%2F10%2F20%2F%E5%9B%BE%E7%89%87%E5%BC%82%E6%88%96%E5%8A%A0%E5%AF%86%2F</url>
    <content type="text"><![CDATA[异或操作异或（Exclusive or）是对两个运算元的一种逻辑分析类型。与一般的逻辑或不同，当两两数值相同时为否，而数值不同时为真。不常使用异或操作符可能容易记错，这里有个小技巧：异或就是求异，找不同。 异或满足一下性质： 结合律：A^(B^C)=(A^B)^C 交换律：A^B=B^A 恒等律：A^0=A 归零律：A^A=0 对合运算：A^B^B=A^0=A 备注：^在编程语言中表示异或，和布尔代数中的运算符“逻辑与”不要弄混。 有一种密码称之为互逆密码，将明文输入密码学系统以获得密文一样，可以将密文输入到系统中的相同位置以获得明文。互易密码有时也称为自反密码。对合运算性质的操作常用于互逆密码。 因此异或操作有一个经典的加密算法即异或密码。 异或密码比如文本串加密，文本串行的每个字符可以通过与给定的密钥进行按位异或运算来加密。如果要解密，只需要将加密后的结果与密钥再次进行按位异或运算即可。 如果使用不断重复的密钥，利用频率分析就可以破解这种简单的异或密码。如果消息的内容被猜出或知道，密钥就会泄露。异或密码值得使用的原因主要是其易于实现，而且计算成本小。简单重复异或加密有时用于不需要特别安全的情况下来隐藏信息。 如果密钥是随机的（不重复），而且与消息长度相同，异或密码就会更为安全。当然异或密码运算符在已知明文攻击下是脆弱的。因为明文^密文=密钥。 设A为明文，B为密钥，C为密文，则A^B=C，则A^C=A^A^B=B，很容易根据A和C求B 字符串异或加密字符串异或加密代码如下： 123456789101112131415161718192021222324252627282930def test_string_xor(): """测试异或加密解密""" message = 'This is a secret message' key = 'whoami' encrypted = string_xor(message, key) decrypted = string_xor(encrypted, key) assert message == decrypted # 输出加密后的字符串,可能是乱码，一般会再base64下 print('xor-encrypted:', encrypted) # 输出解密后的字符串 'This is a secret message' print('xor-decrypted:', decrypted) decrypted_key = string_xor(message, encrypted) # 输出解密后的key 'whoami' print("xor-key:", decrypted_key)def string_xor(message: str, key: str) -&gt; str: """字符串异或""" key_patch = [] len_key = len(key) len_msg = len(message) for i in range(len_msg): if i &gt;= len_key: key_patch.append(key[i % len_key]) else: key_patch.append(key[i]) return "".join([chr(ord(c) ^ ord(k)) for (c, k) in zip(message, key_patch)]) 图片异或加密使用opencv进行图片加密很贱，图片异或加密的代码如下： 123456789101112131415161718192021222324def image_xor(image, image_key): """图片异或""" return cv2.bitwise_xor(image, image_key)def test_image_xor(): """测试图片异或""" img = cv2.imread(data_file_path('data/image/dog_bike_car.jpg')) # 创建一个和原图像大小相同的随机图像 rows, cols, channels = img.shape img_key = np.random.randint(0, 256, (rows, cols, 3), dtype=np.uint8) cv2.imshow('img', img) cv2.imshow('img_key', img_key) img_encrypted = image_xor(img, img_key) cv2.imshow('img_encrypted', img_encrypted) img_decrypted = image_xor(img_encrypted, img_key) cv2.imshow('img_decrypted', img_decrypted) xor_key = image_xor(img, img_encrypted) cv2.imshow('xor_key', xor_key) cv2.waitKey(0) cv2.destroyAllWindows() 直接使用异或加密很简单，但是很不安全，所以异或一般作为更为复杂的加密算法的组成部分。 关于图片强加密有一篇综述写的不错：An overview of encryption algorithms in color images。]]></content>
      <categories>
        <category>CV</category>
      </categories>
      <tags>
        <tag>CV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[敦煌曲子词]]></title>
    <url>%2F2020%2F05%2F17%2F%E6%95%A6%E7%85%8C%E6%9B%B2%E5%AD%90%E8%AF%8D%2F</url>
    <content type="text"><![CDATA[每见惶惶，任他乱芬芳酒泉子 每见惶惶，队队雄军惊玉辇。蓦街穿巷犯皇宫，只拟夺九重。 长枪短剑如麻乱，争奈失计无投窜。金箱玉印自携将，任他乱芬芳。 每见惶惶，泰然处之者几何？ 或有两种人能读出此词芬芳，见惯沧海桑田者，不历艰辛世事者。 且罢，任他乱芬芳 只恨隔蕃部菩萨蛮 敦煌古往出神将，感得诸蕃遥钦仰。效节望龙庭，麟台早有名。 只恨隔蕃部，情恳难申吐。早晚灭狼蕃，一齐拜圣颜。 遥想当年高仙芝，封常清，越葱岭，控西域。 奈何安史之乱，渔阳鼙鼓动地来，大唐最后的安西都护府，已成绝唱。]]></content>
      <categories>
        <category>豪放词</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[24点]]></title>
    <url>%2F2020%2F01%2F10%2F24%E7%82%B9%2F</url>
    <content type="text"><![CDATA[最难忘的游戏大学时代，买入一台组装机，预装了大富翁4，初完颇为兴奋，久完索然乏味。后来室友纷纷推荐，玩了少许新的游戏，最让人沉醉的还是太阁立志传5。那段缤纷绚丽的战国历史犹在眼前，猴子，第六天魔王，独眼龙，风林火山，车悬，无刀取，转，忍犬之术，雷暴之术，村雨，剑圣历历在目。 那些小游戏当我孩子还未长大，我想我会让他熟悉这些小游戏，无论是算数填空，二十一记，还是调制药物，排列茶器，都是值得一试的智力小游戏。我想做一个电脑抑或手机的锁屏游戏，难度随着学历增长吧。啊哈，会成为他的童年乐趣（阴影）吧。 24点我的家人们最喜欢玩的纸牌游戏就是24点了，无论小学生还是研究生，寻找四张牌中的数学奥妙总让人乐此不疲。也许那时就慢慢培养了数学兴趣。 很久就想写下各个小游戏的实现，总是把时间分给了玩游戏，所以做游戏反而不得闲了。后来想也许我得在自己的网站上试试code style。那就小游戏写写吧（玩游戏菜鸟，写游戏亦然）。 表达式穷举123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141public class Point24 &#123; public static void main(String[] args) &#123; calculate(Lists.newArrayList(6, 6, 6, 6)).forEach(System.out::println); System.out.println(); calculate(Lists.newArrayList(1, 2, 1, 7)).forEach(System.out::println); System.out.println(); calculate(Lists.newArrayList(3, 3, 7, 7)).forEach(System.out::println); System.out.println(); calculate(Lists.newArrayList(3, 3, 8, 8)).forEach(System.out::println); System.out.println(); calculate(Lists.newArrayList(1, 5, 5, 5)).forEach(System.out::println); System.out.println(); calculate(Lists.newArrayList(1, 9, 8, 7)).forEach(System.out::println); System.out.println(); &#125; public static Set&lt;String&gt; calculate(List&lt;Integer&gt; numbers) &#123; List&lt;String&gt; opList = new ArrayList&lt;&gt;(); opList.add("+"); opList.add("-"); opList.add("*"); opList.add("/"); List&lt;List&lt;Integer&gt;&gt; numberPerm = Permutation.permutation(numbers); List&lt;List&lt;String&gt;&gt; opSample = Sample.sample(opList, 3); return crossJoin(numberPerm, opSample); &#125; public static Set&lt;String&gt; crossJoin(List&lt;List&lt;Integer&gt;&gt; a, List&lt;List&lt;String&gt;&gt; b) &#123; Set&lt;String&gt; expression = new HashSet&lt;&gt;(); a.forEach(ai -&gt; &#123; b.forEach(bi -&gt; &#123; List&lt;String&gt; result = cal(ai, bi); if (result != null) &#123; expression.addAll(result); &#125; &#125;); &#125;); return expression; &#125; private static List&lt;String&gt; cal(List&lt;Integer&gt; numbers, List&lt;String&gt; ops) &#123; try &#123; List&lt;Exp&gt; exps = numbers.stream().map(i -&gt; new Exp(i.doubleValue())).collect(Collectors.toList()); List&lt;Integer&gt; opIndex = Lists.newArrayList(0, 1, 2); List&lt;List&lt;Integer&gt;&gt; permutation = Permutation.permutation(opIndex); return permutation.stream().map(oi -&gt; &#123; Integer first = oi.get(0); Integer second = oi.get(1); Integer third = oi.get(2); Exp op1 = new Exp(ops.get(first), exps.get(first), exps.get(first + 1)); Exp op2; Exp op3 = new Exp(0.0); if (second - first == 1) &#123; op2 = new Exp(ops.get(second), op1, exps.get(second + 1)); if (third &gt; second) &#123; op3 = new Exp(ops.get(third), op2, exps.get(third + 1)); &#125; else &#123; op3 = new Exp(ops.get(third), exps.get(third), op2); &#125; &#125; else if (second - first == -1) &#123; op2 = new Exp(ops.get(second), exps.get(second), op1); if (third &gt; second) &#123; op3 = new Exp(ops.get(third), op2, exps.get(third + 1)); &#125; else &#123; op3 = new Exp(ops.get(third), exps.get(third), op2); &#125; &#125; else if (second - first == 2) &#123; op2 = new Exp(ops.get(second), exps.get(second), exps.get(second + 1)); op3 = new Exp(ops.get(third), op1, op2); &#125; else if (second - first == -2) &#123; op2 = new Exp(ops.get(second), exps.get(second), exps.get(second + 1)); op3 = new Exp(ops.get(third), op2, op1); &#125; if (Math.abs(op3.value - 24) &lt; 1e-5) &#123; return op3.simpleString(); &#125; return null; &#125;).filter(Objects::nonNull).collect(Collectors.toList()); &#125; catch (Exception e) &#123; &#125; return null; &#125; private static class Exp &#123; private double value; private String exp; public Exp(double value) &#123; this.value = value; this.exp = String.valueOf((int) value); &#125; public Exp(String op, Exp a, Exp b) &#123; value = op(op, a.value, b.value); exp = "(" + a.exp + op + b.exp + ")"; &#125; @Override public String toString() &#123; return exp; &#125; public String simpleString() &#123; if (exp.startsWith("(") &amp;&amp; exp.endsWith(")")) &#123; return exp.substring(1, exp.length() - 1); &#125; else &#123; return exp; &#125; &#125; &#125; private static double op(String op, Double a, Double b) &#123; switch (op) &#123; case "+": return a + b; case "-": return a - b; case "*": return a * b; case "/": return a / b; default: throw new RuntimeException("error op"); &#125; &#125;&#125; 其中有个全排列的类和放回抽样的类，递归是个伟大的发明，它让人类掌握了无穷的力量。 12345678910111213141516171819202122232425262728293031323334353637383940/** * 不放回抽样=全排列 */public class Permutation &#123; public static void main(String[] args) &#123; List&lt;String&gt; abcd = new ArrayList&lt;&gt;(); abcd.add("a"); abcd.add("b"); abcd.add("c"); abcd.add("d"); List&lt;List&lt;String&gt;&gt; result = permutation(abcd); result.forEach(item -&gt; System.out.println(item.stream().collect(Collectors.joining()))); &#125; public static &lt;T&gt; List&lt;List&lt;T&gt;&gt; permutation(List&lt;T&gt; itemList) &#123; List&lt;List&lt;T&gt;&gt; result = new ArrayList&lt;&gt;(); if (itemList.size() == 1) &#123; result.add(itemList); return result; &#125; for (int i = 0; i &lt; itemList.size(); i++) &#123; List&lt;T&gt; otherList = new ArrayList&lt;&gt;(itemList); T first = otherList.remove(i); // 递归公式 p(n)=Σ(0-&gt;n) p1(i)__p(n-i) 其中p(n)返回list&lt;list&gt; p1(i)为返回单元素 __为单元素和list&lt;list&gt;取的逐项拼接逻辑 List&lt;List&lt;T&gt;&gt; otherPermutationResult = permutation(otherList); for (List&lt;T&gt; otherPermutation : otherPermutationResult) &#123; List&lt;T&gt; firstList = new ArrayList&lt;&gt;(); firstList.add(first); firstList.addAll(otherPermutation); result.add(firstList); &#125; &#125; return result; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940/** * 放回抽样 */public class Sample &#123; public static void main(String[] args) &#123; List&lt;String&gt; data = new ArrayList&lt;&gt;(); data.add("a"); data.add("b"); data.add("c"); sample(data, 3).forEach(i -&gt; System.out.println(i.stream().collect(Collectors.joining()))); System.out.println("----"); sample(data, 2).forEach(i -&gt; System.out.println(i.stream().collect(Collectors.joining()))); &#125; public static &lt;T&gt; List&lt;List&lt;T&gt;&gt; sample(List&lt;T&gt; data, int size) &#123; List&lt;List&lt;T&gt;&gt; result = new ArrayList&lt;&gt;(); if (size == 1) &#123; data.forEach(i -&gt; &#123; List&lt;T&gt; item = new ArrayList&lt;&gt;(1); item.add(i); result.add(item); &#125;); return result; &#125; List&lt;List&lt;T&gt;&gt; smallResult = sample(data, size - 1); data.forEach(i -&gt; &#123; smallResult.forEach(s -&gt; &#123; List&lt;T&gt; item = new ArrayList&lt;&gt;(); item.add(i); item.addAll(s); result.add(item); &#125;); &#125;); return result; &#125;&#125; 回溯后来leetcode上给出了一个更为简洁的方案，即从收敛条件看两个数有加减乘除四则运算，其中减除需要交换下，共6种组合。加上除数不能为空判断即可。那么我们的递归逻辑是把大于等于3的数组里面任选2个，转化为1个（四则运算），那么维度降低，知道降低为一维进行求值即可。]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[神采奕奕]]></title>
    <url>%2F2019%2F03%2F24%2F%E7%A5%9E%E9%87%87%E5%A5%95%E5%A5%95%2F</url>
    <content type="text"><![CDATA[神采奕奕小家伙喜欢吃蛋糕，喜欢跳舞，喜欢跳着走路。小家伙喜欢唱歌，喜欢背诵古诗，喜欢飞快的背诵。小家伙喜欢爬高，喜欢床上打滚，喜欢贴画。小家伙喜欢宝宝巴士，喜欢汪汪队，喜欢巧虎。小家伙偶尔不喜欢斑马英语，常常不喜欢吃感冒药。 神采飞扬小家伙会背诵悯农。小家伙会自我介绍。小家伙会数到10了。小家伙会说好吧好的。小家伙会吹响口琴。]]></content>
      <categories>
        <category>奕</category>
      </categories>
      <tags>
        <tag>奕奕</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[素数之恋]]></title>
    <url>%2F2019%2F03%2F24%2F%E7%B4%A0%E6%95%B0%E4%B9%8B%E6%81%8B%2F</url>
    <content type="text"><![CDATA[引子小时候的课程名，是很值得回味的。譬如自然，思想品德，咋一读起，郎朗上口外还有些时间疏离感，仿佛它们只是些美好却又古朴的知识，不如那些一直陪伴，从小学，至中学，甚至大学的基础学科坚守，如语文，数学，物理，化学，过了许多学生时代，它们的名字依然如故。这些名字有着极深的抽象，才能一直简洁的描述这个世界。 物理：格物致理；化学：物各有质，自有变化；数学：九数。这里的九既是九章算术之九，也是数之极，数学本身就是一种无穷的抽象。最近读的就是数论的一角：素数。 素数或者质数，不如说是独数，孤数。整个数字世界中，有效的因子只有自己，也许只有素数才能算独立无二。 以下均为读素数之恋手记。 论文1859年，伯恩哈德·黎曼（Bernhard Riemann）成为柏林科学院的通讯院士，对于一个青年数学家来说（32岁的黎曼），这是一个崇高的荣誉。依照惯例，黎曼向科学院提交了一篇论文，论文题目是：“论小于一个给定值的素数的个数”。 假设ζ函数的所有非平凡零点的实部都是1/2 纸牌游戏和调和级数52张纸牌叠放在桌子上，第一张纸牌向右移动多远才不会掉下来，答案是1/2，此时第一张纸牌的中心刚好在边缘，如果这时候继续移动第二张纸牌，移动多远两张纸牌不会掉下来，答案是1/4，大家可以用杠杆原理求解下（have a try），那么继续移动第三张多远上面的三张纸牌不会掉下来，答案是1/6。是的也许可以按照行测里面的推论题给出答案了，第四张1/8。大家可以加下去也就是1/2+1/4+1/6+1/8+…+1/102。或者1/2*(1+1/2+1/3+1/4+…+1/51)。这就是大名鼎鼎的调和级数1+1/2+1/3+1/4+…+1/n。 调和级数是收敛的么？答案是不，它是发散的。中世纪的晚期的法国学者奥雷姆（Nicole d’Oresme,约1323-1382，这个年代中国处于元末明初，想想当时的华夏应该没有多少人会去想这个问题，也许连倒数还未抽象出来）给出来一个简单的证明。易得：1/3+1/4大于1/2，1/5+1/6+1/7+1/8大于1/2，也即可知这个级数按2的幂次方分段，每段都大于1/2，也即有无限个1/2。即这个级数是发散。 再看看其他的数列，比如1/1,3/2,7/5,17/12,41/29,99/70,239/169…。递推逻辑是分子+分母等于新的分母，分子+2倍的分母等于先得分子。这个数列的极限是2的平方根（1.414…），也就是2^(1/2)。 再看一个有名的数列，1^1,(1+1/2)^2,,(1+1/3)^3,,(1+1/4)^4…,(1+1/n)^n。这个数列的极限大家都比较熟悉了它就是大名鼎鼎的e，自然对数的底数e，2.718281828459…。我们高中遇到它，竟然就自然而然的接受了它，大概是高中的时候我们接受了太多的物理常数（g,G,h）和化学常数（阿伏加德罗），于是对这个e也就见怪不怪了。具体的e的科普可以参见知乎专栏—直观の数学。 再说一个让人珍惜学校时光的话，我们高二就学完了高中的课程，高三这一年大多是温故而知新，其实这个知新最好的的方式不是温故，而是求索，如果你高三能够在温故的同时，学习下奥数，高数，你会获得极大的成长！取得数学状元也有很大可能。进来大学后，教学方式和学习环境变化巨大，这时候如果可以重来我希望能好好的学习数学（我们学校是微积分，线代，复变），是那种充分的理解，能够若干年后还可以形象的从大脑cpu中渲染出来，推理出来的那种理解。而不只是考试得了90+。 素数概率上帝之手-欧拉公式]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
</search>
